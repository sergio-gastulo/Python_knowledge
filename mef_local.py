# -*- coding: utf-8 -*-
"""MEF Local

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w9wZqLUJsNErAiBbLoQZaz6HygOplZPM

Buscamos resolver el problema $$-u'' = f, u(0) = A, u(1) = B$$

Considere
$$ a_{ij} = \int_0^1 \phi_i' \phi_j' dx $$
Además, sea
$$ b_j = \int_0^1 f \phi_j dx $$

buscamos retornar el valor $\alpha$ donde: $A \alpha = B$, para poder hallar $u = \sum \alpha_i \phi_i$.

Consideramos la partición $\{x_i\}$ y $h_i = x_{i} - x_{i-1}$. Sean nuestras funciones elementales
$$ a_0= \phi_0^e(x) = (1-x/h_i)$$
$$a_1 = \phi_1^e(x) = (x/h_i)$$
$$x\in[0,h].$$

Entonces, nuestra matriz elemental es de la forma $$A^e_i = h_i
\begin{pmatrix}
\displaystyle \int_0^1 (a_0')^2 dx
& \displaystyle \int_0^1 a_0'a_1' dx \\
\displaystyle\int_0^1 a_1'a_0' dx
& \displaystyle \int_0^1 (a_1')^2 dx
\end{pmatrix} =
\begin{pmatrix}
\displaystyle 1/h_i
& \displaystyle -1/h_i \\
\displaystyle -1/h_i
& \displaystyle 1/h_i
\end{pmatrix}
$$

Y la parte derecha toma la forma $$ b^e_i =
\begin{pmatrix}
\displaystyle \int_0^{h_j} f(\xi + x_{j}) \phi_0^e(\xi) d\xi \\
\displaystyle \int_0^{h_{j}} f(\xi + x_{j}) \phi_1^e(\xi) d\xi
\end{pmatrix}
$$
"""

import numpy as np
from scipy.special import roots_legendre
from functools import partial
import matplotlib.pyplot as plt

def gauss1d(fun, x0, x1):
    n = 5
    xi, wi = roots_legendre(n)
    inte = 0
    h = 0.5 * (x1 - x0)
    xm = 0.5 * (x0 + x1)
    for cont in range(n):
        inte += h * fun(h * xi[cont] + xm) * wi[cont]
    return inte


f = lambda x: np.sin(x)
A = 0
B = np.sin(1)
n = 10
pp = np.array([i/n for i in range(n+1)])
# pp = np.array([0,0.001,0.8,0.9,0.99,1])
h = np.diff(pp)

Amatrix = np.zeros((n+1,n+1),float)
for i in range(n):
  Amatrix[i][i] += 1/h[i]
  Amatrix[i+1][i] = -1/h[i]
  Amatrix[i][i+1] = -1/h[i]
  Amatrix[i+1][i+1] = 1/h[i]

print(Amatrix)

phi0_e = lambda x,i: 1-x/h[i]
phi1_e = lambda x,i: x/h[i]
ftimesphi0_e = lambda x,i: f(x+pp[i])*phi0_e(x,i)
ftimesphi1_e = lambda x,i: f(x+pp[i])*phi1_e(x,i)


b = np.zeros(n+1,float)
for i in range(n):
  aux0 = partial(ftimesphi0_e, i = i)
  aux1 = partial(ftimesphi1_e, i = i)
  b[i]+= gauss1d(aux0, 0, h[i])
  b[i+1]=gauss1d(aux1, 0, h[i])

'''
    Imponiendo condiciones iniciales:
'''

b[0] = A
b[n] = B
b[1] += A/h[0]
b[n-1] += B/h[n-1]
Amatrix[0][0] = 1
Amatrix[n][n] = 1
Amatrix[1][0] = 0
Amatrix[0][1] = 0
Amatrix[n-1][n] = 0
Amatrix[n][n-1] = 0

alfa = np.linalg.solve(Amatrix,b)
xx = np.linspace(0,1,25)
for i in range(len(pp)):
  plt.scatter(pp[i],alfa[i],c = 'red',s = 10)
plt.plot(xx, np.sin(xx),label='solcuión exacta', c= 'blue')
plt.legend()