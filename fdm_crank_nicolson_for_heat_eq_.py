# -*- coding: utf-8 -*-
"""FDM - Crank Nicolson for Heat Eq.

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vvU-qszLT3HMYszJ3omChVC7UAnGznWb

Buscamos resolver numéricamente la ecuación
\begin{align*}
  u_t  &= \alpha^2 u_{xx} \\
u(x,0) &= g(x)\\
u(0,t) &= A \\
u(L,t) &= B \\
(t,x) &\in \mathbb{R}^{+} \times (0,L)
\end{align*}

El esquema a seguir es el siguiente:

$$ - \lambda U_i^{j+1} + (1+2\lambda) U_i^{j+1} - \lambda U_i^{j+1} = \lambda U_{i-1}^j + (1-2\lambda) U_i^j + \lambda U_{i+1}^j, $$

Donde $i = 1, ..., n-1, j = 1, ...m-1$ y $\lambda = \dfrac{\alpha^2 k}{2 h^2}$
"""

import numpy as np
import matplotlib.pyplot as plt
from numpy import pi as pi
from numpy import exp as exp
from numpy import cos as cos
from numpy import sin as sin

solution = lambda x,t: sin(pi * x) * exp(-pi**2 * t)
g = lambda x: sin(pi *x)
alfa = 1
L,T = 1, 1 # T = límite de la discretización del tiempo
A, B = 0, 0
n,m = 10,500
xx = np.linspace(0,L,n+1)
tt = np.linspace(0,T,m+1)
h, k = L/n, T/m
l = (alfa**2 * k) / (2 * h**2)

"""Los datos previamente insertados corresponden a la EDP
\begin{align*}
u_t &= u_{xx}, \quad x \in (0,1) , t>0 \\
u(x,0) &= \sin (\pi x)\\
u (0,t) &= 0\\
u (1,t) &= 0
\end{align*}
"""

U = np.zeros((n+1,m+1),float)

U[0,:] = np.full(m+1,A)
U[-1,:] = np.full(m+1,B)
U[:,0] = g(xx)

# Ashadow = np.zeros((n+1,n+1),float)
# np.fill_diagonal(Ashadow[1:], np.full(n,l))
# np.fill_diagonal(Ashadow, np.full(n+1, 1-2*l))
# np.fill_diagonal(Ashadow[:, 1:], np.full(n,l))
Ashadow = np.zeros((n-1,n-1),float)
np.fill_diagonal(Ashadow[1:], np.full(n-2,l))
np.fill_diagonal(Ashadow, np.full(n-1, 1-2*l))
np.fill_diagonal(Ashadow[:, 1:], np.full(n-2,l))
#
Bshadow = np.zeros((n-1,n-1),float)
np.fill_diagonal(Bshadow[1:], np.full(n-2,-l))
np.fill_diagonal(Bshadow, np.full(n-1, 1+2*l))
np.fill_diagonal(Bshadow[:, 1:], np.full(n-2,-l))
# Bshadow = np.zeros((n+1,n+1),float)
# np.fill_diagonal(Bshadow[1:], np.full(n,-l))
# np.fill_diagonal(Bshadow, np.full(n+1, 1+2*l))
# np.fill_diagonal(Bshadow[:, 1:], np.full(n,-l))
# print(Bshadow)
# print(Ashadow)

r = np.zeros(n-1,float)
r[0]  = 2 * l * A
r[-1] = 2 * l * B

for j in range(1,m+1):
  U[1:-1,j] = np.linalg.solve(Bshadow,np.dot(Ashadow,U[1:-1,j-1])) + r

count = 250
plt.scatter(xx,U[:,count], s = 5, c = 'red', label= 'discretizacion en t=' + str(tt[count]))
plt.plot(xx,solution(xx,tt[count]), c = 'blue', label = 'solucion en t =' + str(tt[count]))
plt.title("Solución exacta $u(x,t) = \sin (\pi x) e^{-\pi^2 t}$")
plt.legend()

from decimal import Decimal

dash = '-'*40
for i in range(n+1):
  if i==0:
    print(dash)
    print('{:^6s}{:1.5f}{:^6s}'.format("error en cada punto de u(x,t= ",tt[count],")"))
    print(dash)
  print("{:>10s}{:>.3f}{:>15.5e}".format("x = ", xx[i], Decimal(np.abs(solution(xx[i],tt[count]) - U[i][count]))))

# print("error en cada punto ")
# for i in range(n):
  # print('{2:4f}'.format(np.abs()))
